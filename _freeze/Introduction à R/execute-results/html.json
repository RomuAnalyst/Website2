{
  "hash": "fa335c36b27c2474fd61e2fba2d8a380",
  "result": {
    "markdown": "---\nauthor: \"Romuald / IUT Paris 5\"\ndate: \"01/01/2023\"\nexecute: \n  message: false\n  warning: false\n  output: true\nreference-location: margin\neditor_options: \n  chunk_output_type: console\npage-layout: full\ninclude-in-header: \n  - _includes/fontawesome-2up.html\ntoc: true\ntoc-title: Table des matières\n---\n\n\n\n\n# Bases du langage\n\nDans ce cours d'introduction à R, nous aborderons les principes fondamentaux du langage de programmation R ainsi que ses applications dans l'analyse de données. Le cours précédent a débuté par une présentation de l'environnement de développement RStudio. Ici, nous examinerons les concepts clés de la programmation en R, tels que les variables, les fonctions, les boucles et les conditions. Nous acquerrons également des compétences dans la manipulation des structures de données courantes telles que les vecteurs, les matrices et les data frames. De plus, nous traiterons des sujets tels que l'importation et l'exportation de données, ainsi que le nettoyage et la transformation des jeux de données.  \nCe cours d'introduction à R fournit les bases nécessaires pour débuter la programmation en R.  \n\nLes cours à venir se concentreront sur une introduction aux techniques de visualisation de données à l'aide de graphiques de base, ainsi que sur l'utilisation de packages populaires tels que ggplot2.\n\n\n\n## Commandes : créer, lister et effacer les objets en mémoire\n\nIl y a deux types de commandes en `R`: les expressions et les affectations.\n\n**Expression**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint('Hello world!')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hello world!\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npi\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3.141593\n```\n:::\n:::\n\n\n**Affectations et expressions**\n\nUn objet peut être créé avec l'opérateur **assigner** qui s'écrit `<-`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx<-1+2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nou de manière équivalente avec `=`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx=1+3\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\nSi l'objet existe déjà, sa valeur précédente est effacée :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx=10+2\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ny=4\nx+y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16\n```\n:::\n:::\n\n\nA l'aide de `;` on peut taper deux commandes sur la même ligne avant leur exécution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb=3; x+y-3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 13\n```\n:::\n:::\n\n\nLa fonction `ls()` permet d'afficher une liste simple des objets en mémoire, c'est-à-dire que seuls les noms des objets sont affichées.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- \"Carmen\"\nn1 <- 10\nn2 <- 100\nm <- 0.5\nls()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"b\"               \"has_annotations\" \"m\"               \"n1\"             \n[5] \"n2\"              \"name\"            \"x\"               \"y\"              \n```\n:::\n:::\n\n\n# Eléments de langage : modes, longueurs et classes de données\n\nNous allons voir ici les différentes structures de données utilisées dans **R**, ainsi que les moyens de les créer et de les manipuler.\n\n## Les objets\n\nDans **R**, tout est un objet. **R** manipule donc des objets qui sont caractérisés par leur nom, leur contenu mais aussi par des attributs qui vont spécifier le type de données représenté par un objet. Les objets ont tous deux attributs intrinsèques : le **mode** et la **longueur**.\n\n1.  le mode spécifie ce qu'un objet peut contenir. Il s'obtient à l'aide de la fonction `mode`. Les modes principaux sont:\n\n-   `numeric` : nombres réels\n-   `character`: chaînes de caractères\n-   `logical` : valeurs logiques vrai/faux ( **TRUE** / **FALSE** ou **T** / **F** sur **R**)\n-   `list`: liste, collection d'objets\n-   `function`: fonction\n\nLes objets de mode `numeric`, `character` et `logical`, sont des objets *simples* qui peuvent contenir des données d'un seul type. Au contraire, les objets de mode `list` sont des objets spéciaux qui peuvent contenir des objets de types différents.\n\n2.  la longueur est le nombre d'éléments de l'objet. Elle s'obtient à l'aide de la fonction `length`. Un objet de mode **character** doit contenir plusieurs chaînes de caractères pour que sa longueur soit supérieure à 1. Un objet peut être de longueur 0 et doit alors être interprété comme un contenant qui existe mais qui est vide.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\nmode(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- c(\"test\")\nmode(x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nlength(x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nnchar(x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nmode(nchar)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n\n```{.r .cell-code}\nx2 <- c(\"test1\", \"test2\") # La fonction de concatenation c() permet de créer des vecteurs\nlength(x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nnchar(x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 5\n```\n:::\n\n```{.r .cell-code}\nt <- TRUE\nmode(t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\nlength(t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nmode(mode)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"function\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nage <- c(33,28,33)\nmode(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nlength(age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nnoms <- c('Daniel', 'Jeanne', 'Romain')\nmode(noms)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nlength(noms)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nma.liste <- list(Noms=noms, Age=age)\nma.liste\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$Noms\n[1] \"Daniel\" \"Jeanne\" \"Romain\"\n\n$Age\n[1] 33 28 33\n```\n:::\n\n```{.r .cell-code}\nmode(ma.liste)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n\n```{.r .cell-code}\nlength(ma.liste)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nlength(ma.liste$Noms)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nmode(ma.liste$Noms)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nmode(ma.liste$Age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n## Les objets spéciaux\n\n**NULL**\n\nL'objet spécial **NULL** représente \"rien\" ou le vide. Son mode est **NULL**, sa longueur 0.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmode(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"NULL\"\n```\n:::\n\n```{.r .cell-code}\nlength(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\nDans les applications statistiques, il est souvent utile de pouvoir représenter des données manquantes.\n\n**NA**\n\nDans **R**, l'objet spécial **NA** remplit ce rôle. NA signifiant : Not Allowed (valeur non allouée). Par défaut, le mode de **NA** est **logical** cependant `NA` n'est ni `TRUE` ni `FALSE`. Toute opération impliquant une donnée **NA** a comme résultat **NA** mais certaines fonctions (`sum`, `mean`,...) ont un argument **na.rm** qui, lorsque **TRUE**, élimine les données manquantes. La valeur **NA** n'est égale à aucune autre, pas même à elle même.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA==NA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nPar conséquent, pour tester si les éléments d'un objet sont **NA** ou non, il faut utiliser la fonction **is.na**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.na(mean(c(1,4,NA)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nmean(c(1,4,NA),na.rm=T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5\n```\n:::\n:::\n\n\nIl existe différents types d'objets qui sont détaillés dans les sections suivantes. Les fonctions `is.<type>()` permettent de tester si l'objet en paramètre est du type demandé.\n\n## Type **vector**\n\nEn **R** l'unité de base dans les calculs est le *vecteur* c'est-à-dire que tout est **vector** de base (au minimum). Il n'existe pas de type **scalaire**. Un scalaire est simplement un vecteur de longueur 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na<-3\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nclass(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nis.vector(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n-   Comme évoqué précédemment, la fonction de base la plus utilisée pour créer un vecteur est `c` commme concaténation :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprix <- c(150, 162, 155, 157); prix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 150 162 155 157\n```\n:::\n:::\n\n\nLes autres fonctions de base pour créer des vecteurs sont :\n\n-   `numeric` (vecteur de mode `numeric`)\n-   `character` (vecteur de mode `character`)\n-   `logical` (vecteur de mode `logical`)\n\nAttention dans un vecteur simple, tous les éléments doivent avoir le même mode:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2, 'a', 'b'); x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\" \"2\" \"a\" \"b\"\n```\n:::\n\n```{.r .cell-code}\nmode(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\nmode(prix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\nIl est également possible de donner une étiquette à chacun des éléments d'un vecteur.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(a=1,b=2,c=5)\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na b c \n1 2 5 \n```\n:::\n\n```{.r .cell-code}\nv <- c(1,2,5)\nnames(v) <- c(\"a\",\"b\",\"c\")\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na b c \n1 2 5 \n```\n:::\n:::\n\n\n\n### Indiçage\n\nL'indiçage dans un vecteur se fait avec les crochets \\[ \\]. On peut extraire un élément d'un vecteur par sa position ou par son étiquette.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na b c \n1 2 5 \n```\n:::\n\n```{.r .cell-code}\nv[2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nb \n2 \n```\n:::\n\n```{.r .cell-code}\nv[\"b\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nb \n2 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprix[1] # Le premier indice est toujours 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 150\n```\n:::\n\n```{.r .cell-code}\nprix[c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 150 155\n```\n:::\n\n```{.r .cell-code}\nprix[-c(1,2)] # pour extraire tous les éléments sauf le 1e et le 2e\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 155 157\n```\n:::\n:::\n\n\nOn peut aussi utiliser un vecteur d'indiçage booléen, les éléments extraits sont bien évidement ceux correspondant aux valeurs `TRUE`. Par exemple pour extraire les prix supérieurs à 156 :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprix > 156 # le vecteur booléen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\nprix[prix>156] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 162 157\n```\n:::\n:::\n\n\nUne alternative est donnée par la fonction `which()`qui rend les indices dont les éléments vérifient une condition logique :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhich(prix>155)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4\n```\n:::\n\n```{.r .cell-code}\nprix[which(prix>156)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 162 157\n```\n:::\n:::\n\n\nOn peut utiliser l'indiçage pour changer un élément:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprix[1] <- 0; prix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]   0 162 155 157\n```\n:::\n:::\n\n\nIl est possible d'extraire des éléments sur la base des étiquettes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(prix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n\n```{.r .cell-code}\nnames(prix) <- c('model.1', 'model.2', 'model.3', 'model.4')\nprix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmodel.1 model.2 model.3 model.4 \n      0     162     155     157 \n```\n:::\n\n```{.r .cell-code}\nprix['model.3']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmodel.3 \n    155 \n```\n:::\n:::\n\n\nEn résumé, il existe quatre façons d'indicer un vecteur (matrice ou data frame) dans **R** :\n\n-   avec un vecteur d'entiers positifs. Les éléments se trouvant aux positions correspondant aux entiers sont extraits du vecteur dans l'ordre :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(8,7,-9,2,-1)\nnames(v) <- c(\"a\",\"b\",\"c\",\"d\",\"e\")\nv\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n a  b  c  d  e \n 8  7 -9  2 -1 \n```\n:::\n\n```{.r .cell-code}\nv[c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n a  c \n 8 -9 \n```\n:::\n:::\n\n\n-   avec un vecteur d'entiers négatifs. Les éléments se trouvant aux positions correspondant aux entiers sont alors éliminés du vecteur :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv[-c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n b  d  e \n 7  2 -1 \n```\n:::\n:::\n\n\n-   avec un vecteur booléen. Le vecteur d'indiçage doit alors être de même longueur que le vecteur indicé. Seuls les éléments correspondant à une valeur **TRUE** sont extraits du vecteur :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv>0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    a     b     c     d     e \n TRUE  TRUE FALSE  TRUE FALSE \n```\n:::\n\n```{.r .cell-code}\nv[v>0]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na b d \n8 7 2 \n```\n:::\n:::\n\n\n-   avec un vecteur de chaîne de caractères (utile pour extraire les éléments d'un vecteur à condition que ceux-ci soient nommés) :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv[c(\"a\",\"c\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n a  c \n 8 -9 \n```\n:::\n:::\n\n\n\n\n### Créer des vecteurs de type `numeric`\n\nPour créer des vecteurs de type `numeric`, d'autres commandes peuvent être utiles :\n\n**fonction `:`**\n\n-   `:` pour des suites d'entiers consécutifs\n\nPour générer le vecteur des $n$ premiers entiers on utilise la syntaxe `1:n`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n```{.r .cell-code}\n2:6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4 5 6\n```\n:::\n:::\n\n\n**fonction `seq`**\n\n-   `seq` pour des suites (plus générales) d'éléments\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1:5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1,5,by=.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(5,1,by=-.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.0 4.5 4.0 3.5 3.0 2.5 2.0 1.5 1.0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1,5,length=6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.0 1.8 2.6 3.4 4.2 5.0\n```\n:::\n:::\n\n\n**fonction `rep`**\n\n-   `rep` pour des éléments répétés\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(1:5,times=3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(1:5,each=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 2 2 3 3 4 4 5 5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(1:5,each=2,times=3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 2 2 3 3 4 4 5 5 1 1 2 2 3 3 4 4 5 5 1 1 2 2 3 3 4 4 5 5\n```\n:::\n:::\n\n\n## Type **matrix** et **array**\n\nLes matrices ne sont rien d'autre que des vecteurs dotés d'un attribut dimension de longueur 2 contenant les dimensions de la matrice. Tous les éléments d'une matrice ont donc le même mode. La fonction de base pour créer des matrices est `matrix`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(0,nrow=2,ncol=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    0    0    0    0    0\n[2,]    0    0    0    0    0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(1:10,2,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    3    5    7    9\n[2,]    2    4    6    8   10\n```\n:::\n:::\n\n\nLa fonction `matrix` remplit naturellement la matrice par colonnes. L'argument `byrow` permet d'inverser l'ordre de remplissage.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(1:10,2,5,byrow=TRUE)\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n```\n:::\n:::\n\n\nL'instruction `dim` donne les dimensions de la matrice : nombre de lignes et nombres de colonnes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 5\n```\n:::\n:::\n\n\nOn utilise les `[,]` pour accéder aux éléments de la matrice, avec tout ce qui est pour les lignes avant la virgule, et pour les colonnes, après. On peut aussi ne donner que la position de l'élément dans le vecteur sous-jacent. Lorsqu'une dimension est omise dans les crochets, tous les éléments de cette dimension sont extraits.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm[1,2] # element de la 1e ligne et 2e colonne\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nm[3]   # 3e element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nm[1,]  # 1ere ligne\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nm[,2]  # 2e colonne\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 7\n```\n:::\n\n```{.r .cell-code}\nm[,-2] # pour extraire toutes les colonnes sauf la 2e\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    4    5\n[2,]    6    8    9   10\n```\n:::\n:::\n\n\nDes fonctions permettent de fusionner des matrices ayant au moins une dimension identique :\n\n-   `rbind` : fusionne verticalement des matrices ayant le même nombre de colonnes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrbind(m,m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]    1    2    3    4    5\n[4,]    6    7    8    9   10\n```\n:::\n:::\n\n\n-   `cbind` : fusionne horizontalement des matrices ayant le même nombre de lignes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncbind(m,m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]    1    2    3    4    5    1    2    3    4     5\n[2,]    6    7    8    9   10    6    7    8    9    10\n```\n:::\n:::\n\n\nLa généralisation d'une matrice à plus de deux dimensions est un tableau **array**. La fonction de base pour créer des tableaux est `array`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\narray(1:24,dim=c(3,4,2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n, , 1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\n, , 2\n\n     [,1] [,2] [,3] [,4]\n[1,]   13   16   19   22\n[2,]   14   17   20   23\n[3,]   15   18   21   24\n```\n:::\n:::\n\n\n# Opérateurs et fonctions\n\n## Opérations sur vecteurs et matrices numériques\n\nLes opérations sur les vecteurs sont effectuées élément par élément :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(3,4,1,6)\nv + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 6 3 8\n```\n:::\n\n```{.r .cell-code}\nv * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  8  2 12\n```\n:::\n\n```{.r .cell-code}\nv * v\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  9 16  1 36\n```\n:::\n\n```{.r .cell-code}\nv/2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.5 2.0 0.5 3.0\n```\n:::\n\n```{.r .cell-code}\nv/v\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 1 1\n```\n:::\n\n```{.r .cell-code}\nv + v^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12 20  2 42\n```\n:::\n\n```{.r .cell-code}\nsqrt(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        [,1]     [,2]     [,3] [,4]     [,5]\n[1,] 1.00000 1.414214 1.732051    2 2.236068\n[2,] 2.44949 2.645751 2.828427    3 3.162278\n```\n:::\n\n```{.r .cell-code}\nm * m\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    4    9   16   25\n[2,]   36   49   64   81  100\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx<- c(1,2,3)\ny <- c(4,5,6)\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 7 9\n```\n:::\n\n```{.r .cell-code}\nx*y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4 10 18\n```\n:::\n:::\n\n\nSi les vecteurs impliqués dans une expression arithmétique ne sont pas de la même longueur, les plus courts sont récyclés de façon à correspondre au plus long vecteur.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10 + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  4  5  6  7  8  9 10 11 12\n```\n:::\n:::\n\n\nSi la longueur du plus long vecteur est un multiple de celle du (ou des) autres vecteurs, ces derniers sont recyclés un nombre entier de fois. Sinon, le plus court vecteur est recyclé un nombre fractionnaire de fois mais comme ce résultat est rarement souhaité, un avertissement est affiché.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10 + 1:5 + c(2,4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  4  8  8 12 12 11 11 15 15 19\n```\n:::\n\n```{.r .cell-code}\n1:10 + rep(1:5,2) + rep(c(2,4),5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  4  8  8 12 12 11 11 15 15 19\n```\n:::\n\n```{.r .cell-code}\n1:10 + c(2, 4, 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  3  6  9  6  9 12  9 12 15 12\n```\n:::\n\n```{.r .cell-code}\nm + v\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    4    3    6    5    8\n[2,]   10   13   12   15   14\n```\n:::\n:::\n\n\n## Quelques fonctions utiles\n\nLe langage **R** compte un très grand nombre de fonctions internes permettant de :\n\n-   extraire des éléments de vecteurs :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6\n```\n:::\n\n```{.r .cell-code}\nhead(1:10,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\ntail(1:10,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  8  9 10\n```\n:::\n\n```{.r .cell-code}\nunique(c(2,4,2,5,9,5,1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 5 9 1\n```\n:::\n:::\n\n\n-   ordonner des vecteurs :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsort(c(4,-1,2,6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1  2  4  6\n```\n:::\n\n```{.r .cell-code}\nrank(c(4,-1,2,6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 1 2 4\n```\n:::\n\n```{.r .cell-code}\norder(c(4,-1,2,6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 1 4\n```\n:::\n\n```{.r .cell-code}\nrev(c(4,-1,2,6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6  2 -1  4\n```\n:::\n:::\n\n\n-   rechercher des éléments dans un vecteur :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(4,-1,2,-3,6)\nwhich(x>0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5\n```\n:::\n\n```{.r .cell-code}\nwhich.min(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nwhich.max(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nmatch(2,x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n-1:2 %in% x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE  TRUE\n```\n:::\n:::\n\n\n-   arrondir les éléments d'un vecteur :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10*runif(10) # Permet de générer un vecteur aléatoire suivant une loi uniforme\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 9.3161842 9.2090853 7.3105590 9.9608965 7.4405469 9.5947470 1.2408265\n [8] 9.3861557 0.9932954 3.5417271\n```\n:::\n\n```{.r .cell-code}\nround(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  9  9  7 10  7 10  1  9  1  4\n```\n:::\n\n```{.r .cell-code}\nround(x,3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 9.316 9.209 7.311 9.961 7.441 9.595 1.241 9.386 0.993 3.542\n```\n:::\n\n```{.r .cell-code}\nfloor(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 9 9 7 9 7 9 1 9 0 3\n```\n:::\n\n```{.r .cell-code}\nceiling(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 10 10  8 10  8 10  2 10  1  4\n```\n:::\n\n```{.r .cell-code}\ntrunc(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 9 9 7 9 7 9 1 9 0 3\n```\n:::\n:::\n\n\n-   faire des opérations sur les matrices :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(1:4,nrow=2,ncol=2)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\nnrow(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nncol(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nrowSums(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 6\n```\n:::\n\n```{.r .cell-code}\nrowMeans(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3\n```\n:::\n\n```{.r .cell-code}\nt(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n```\n:::\n\n```{.r .cell-code}\ndiag(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4\n```\n:::\n\n```{.r .cell-code}\nx %*% x # Attention : produit matriciel !\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    7   15\n[2,]   10   22\n```\n:::\n:::\n\n\n## Type **factor**\n\nPuisque **R** est un langage orienté statistique, il dispose d'un type particulier permettant de coder des variables qualitatives, le type **factor**. Un facteur est un vecteur utilisé pour contenir une variable qualitative autrement dit c'est un vecteur avec une liste prédéfinie de valeurs que l'on appelle modalités, catégories ou niveaux (**levels** en **R**).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nville <- c('paris', 'lyon', 'lyon', 'paris', 'nantes')\nfact.ville <- as.factor(ville); fact.ville\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] paris  lyon   lyon   paris  nantes\nLevels: lyon nantes paris\n```\n:::\n\n```{.r .cell-code}\nclass(fact.ville)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n\n```{.r .cell-code}\nlevels(fact.ville)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"lyon\"   \"nantes\" \"paris\" \n```\n:::\n:::\n\n\nUn facteur a le mode `numeric` : en effet ses éléments sont stockés comme les entiers énumérant les différentes modalités :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmode(fact.ville)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nas.numeric(fact.ville)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 1 1 3 2\n```\n:::\n:::\n\n\nComme nous pouvons le voir en transformant la variable en **numeric**, chaque modalité est codée numériquement (en valeur entière de 1 à $n$, $n$ désignant le nombre total de niveaux) et garde la liste des niveaux en plus.\n\n## Type **list**\n\nLa liste est le mode de stockage le plus général de **R**, permettant de mettre ensemble des éléments de différents types et mode, y compris `list`. Cela permet donc d'emboîter des listes. La fonction de base pour créer des listes est `list()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- list(1:5,month.abb,pi)\nl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3 4 5\n\n[[2]]\n [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n\n[[3]]\n[1] 3.141593\n```\n:::\n:::\n\n\nLa liste demeure un vecteur. On peut donc l'indicer avec \\[ \\]. Cependant, cela retourne une liste contenant le ou les éléments indicés. C'est rarement ce que l'on souhaite. Pour indicer un élément d'une liste et n'obtenir que cet élément, il faut utiliser \\[\\[ \\]\\]. On ne peut alors extraire qu'un seul élément à la fois.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nl[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nl[[1]][1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nSi les éléments d'une liste sont nommés par des étiquettes, on peut alors utiliser l'opérateur \\$ à la place de \\[\\[ \\]\\].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- list(x=1:5,mois=month.abb,pi=pi)\nl$x\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\nLa fonction \\texttt{unlist()} convertit une liste en vecteur simple.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                x1                 x2                 x3                 x4 \n               \"1\"                \"2\"                \"3\"                \"4\" \n                x5              mois1              mois2              mois3 \n               \"5\"              \"Jan\"              \"Feb\"              \"Mar\" \n             mois4              mois5              mois6              mois7 \n             \"Apr\"              \"May\"              \"Jun\"              \"Jul\" \n             mois8              mois9             mois10             mois11 \n             \"Aug\"              \"Sep\"              \"Oct\"              \"Nov\" \n            mois12                 pi \n             \"Dec\" \"3.14159265358979\" \n```\n:::\n:::\n\n\n-   chercher des éléments d'une liste :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl = list(a = \"chaîne\", \n  b = 12, \n  c = 1:10, \n  d = month.abb, \n  e = list(x = 1:10, y = log(1:10)))\nFind(is.vector, l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"chaîne\"\n```\n:::\n\n```{.r .cell-code}\nFind(is.vector, l, right=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$y\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246 2.3025851\n```\n:::\n\n```{.r .cell-code}\nPosition(is.vector, l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nFilter(is.vector, l)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] \"chaîne\"\n\n$b\n[1] 12\n\n$c\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$d\n [1] \"Jan\" \"Feb\" \"Mar\" \"Apr\" \"May\" \"Jun\" \"Jul\" \"Aug\" \"Sep\" \"Oct\" \"Nov\" \"Dec\"\n\n$e\n$e$x\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$e$y\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246 2.3025851\n```\n:::\n:::\n\n\n## Type **data.frame**\n\nLa *classe* d'un objet spécifie son comportement et donc sa façon d'interagir avec les opérations et les fonctions. L'exemple probablement le plus important est le *data frame*: une liste spéciale dont les éléments ont tous la même longueur. En effet, même si les vecteurs, matrices et listes sont les types d'objet les plus fréquement utilisés sous **R**, un grand nombre de procédures statistiques reposent sur les **data.frame** pour le stockage des données. Bien que visuellement similaire à une matrice (représentation sous la forme d'un tableau à deux dimensions dont les colonnes sont ses éléments), un **data.frame** est plus général puisque les colonnes peuvent être de modes différents. Typiquement, dans un data frame les colonnes représentent les **variables** et les ligne les **observations**.\n\nLa commande de base pour créer un **data.frame** est **data.frame()** ou **as.data.frame()** pour convertir un autre type d'objets en data frame. L'élément distinctif entre un data frame et une liste générale, c'est que tous les éléments du premier doivent être de même longueur et que, par conséquent, **R** les dispose en colonnes.La classe d'un data frame est différente de celle des listes génériques et les data frame ont un système d'indiçage qui n'existe pas pour les autres listes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid <- c('id.453', 'id.452', 'id.455', 'id.459', 'id.458', 'id.456', 'id.450', 'id.451')\nage <- c(19, 45, 67, 53, 17, 30, 27, 35)\nfumeur <- c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE)\nsex <- c('f', 'f', 'h', 'h', 'f', 'h', 'f', 'f')\nma.bd <- data.frame(Id=id, Age=age, Fumeur=fumeur, Sex=sex); ma.bd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Id Age Fumeur Sex\n1 id.453  19   TRUE   f\n2 id.452  45  FALSE   f\n3 id.455  67   TRUE   h\n4 id.459  53   TRUE   h\n5 id.458  17  FALSE   f\n6 id.456  30   TRUE   h\n7 id.450  27   TRUE   f\n8 id.451  35   TRUE   f\n```\n:::\n\n```{.r .cell-code}\ndim(ma.bd); nrow(ma.bd); ncol(ma.bd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8 4\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n\n```{.r .cell-code}\nnames(ma.bd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Id\"     \"Age\"    \"Fumeur\" \"Sex\"   \n```\n:::\n:::\n\n\nUn data frame étant une liste, on pourra extraire une colonne à l'aide de l'opérateur `$` précédé par le nom du data frame et suivi par le nom de la colonne (ou variable), ou utiliser l'opérateur `[]`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nma.bd$Sex # une colonne de caractères est transformée automatiquement en facteur\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"f\" \"f\" \"h\" \"h\" \"f\" \"h\" \"f\" \"f\"\n```\n:::\n\n```{.r .cell-code}\nma.bd[,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19 45 67 53 17 30 27 35\n```\n:::\n\n```{.r .cell-code}\nma.bd$Age[ma.bd$Fumeur==FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 45 17\n```\n:::\n:::\n\n\nLes colonnes sont directement accessibles dans l'espace de travail (sans devoir taper le nom du data frame et le `$`) après avoir **attaché** le data frame. En effet, on peut travailler directement avec les colonnes d'un data frame en travailler sur leur noms à l'aide de la fonction `attach`(cela les rend visibles dans l'espace de travail). Il est possible d'annuler cela avec `detach`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattach(ma.bd)\nAge\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 19 45 67 53 17 30 27 35\n```\n:::\n\n```{.r .cell-code}\ndetach(ma.bd)\n```\n:::\n\n\nPour afficher seulement les six premières lignes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(ma.bd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Id Age Fumeur Sex\n1 id.453  19   TRUE   f\n2 id.452  45  FALSE   f\n3 id.455  67   TRUE   h\n4 id.459  53   TRUE   h\n5 id.458  17  FALSE   f\n6 id.456  30   TRUE   h\n```\n:::\n:::\n\n\nPour afficher seulement les six dernières lignes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(ma.bd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Id Age Fumeur Sex\n3 id.455  67   TRUE   h\n4 id.459  53   TRUE   h\n5 id.458  17  FALSE   f\n6 id.456  30   TRUE   h\n7 id.450  27   TRUE   f\n8 id.451  35   TRUE   f\n```\n:::\n:::\n\n\nLes jeux de données contenus dans **R** sont (presque) toujours des data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(mtcars)\nstr(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n```\n:::\n:::\n\n\nVous pouvez utiliser la fonction `View(mtcars)` pour visualiser votre jeu de données.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars[1,]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          mpg cyl disp  hp drat   wt  qsec vs am gear carb\nMazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars$mpg\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n```\n:::\n\n```{.r .cell-code}\nmtcars[,\"mpg\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars[\"Mazda RX4\",]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          mpg cyl disp  hp drat   wt  qsec vs am gear carb\nMazda RX4  21   6  160 110  3.9 2.62 16.46  0  1    4    4\n```\n:::\n:::\n\n\n## Petit retour sur le type **factor** sur le jeu de données **iris**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(iris)\nstr(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n```\n:::\n\n```{.r .cell-code}\nlevels(iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"setosa\"     \"versicolor\" \"virginica\" \n```\n:::\n\n```{.r .cell-code}\niris$Species[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] setosa setosa setosa setosa setosa\nLevels: setosa versicolor virginica\n```\n:::\n\n```{.r .cell-code}\nas.numeric(iris$Species[1:5])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 1 1 1 1\n```\n:::\n\n```{.r .cell-code}\nas.character(iris$Species[1:5])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"setosa\" \"setosa\" \"setosa\" \"setosa\" \"setosa\"\n```\n:::\n:::\n\n\nLe plus souvent on travaille sur des jeux de données que l'on importe c'est-à-dire qui ne sont pas directement disponibles dans **R**.\n\n# Importation et exportation des données\n\nL'importation des données est l'étape fondamentale de l'analyse de données. Pour charger dans l'espace de travail (c'est à dire dans la mémoire) les données stockées dans un fichier (de type: texte, .csv, excel, ...) on utilise la fonction `read.table()` ayant de nombreux arguments! Cette dernière nous renvoie un data frame. Elle est le moyen principal pour lire des fichiers de données à l'aide de **R**.\n\nMais avant toute chose il faut connaitre le répertoire de travail ! En effet, si les données sont stockées (ou doivent être sauvegardées) localement, il est nécessaire de connaître (et de pouvoir modifier) le répertoire de travail:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd() # essayer sur sa machine!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/Users/romuanalyst/Documents/GitHub/Website\"\n```\n:::\n\n```{.r .cell-code}\nsetwd('~/Documents') # pour se déplacer dans le répertoire Documents\n```\n:::\n\n\nOn rappelle que dans les machines Linux et OS, `~/` est un raccourci pour `/Users/nom_utilisateur`. Pour les machines Windows, la syntaxe des adresses est légèrement différente. Par exemple on utilise `\\` à la place de `/` .\n\nRevenons à notre fonction `read.table()`. Ses trois arguments les plus importants sont:\n\n-   `file`: nom (et adresse) du fichier, entre \"guillemets\".\n\n-   `header`: les variables sont nommées par défaut **V1,...**. La commande `header` (**FALSE** ou **TRUE**) indique si le fichier contient les noms des variables sur la première ligne et permet donc ainsi d'attribuer des noms aux variables.\n\n-   `sep`: le séparateur de champ est le caractère séparant les colonnes . Il doit être défini suivant le fichier (`sep=$\\backslash$t` pour la tabulation par exemple).\n\n-   Fichier txt :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_txt <- read.table(file=\"Fichiers/iris.txt\",\n                          header=TRUE, # la première ligne contient le nom des variables\n                          sep='\\t' # les variables sont separées par des tabulations\n                          )\nstr(my_data_txt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : chr  \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...\n```\n:::\n:::\n\n\n-   Fichier csv :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_csv <- read.table(file=\"Fichiers/iris.csv\",\n                          header=TRUE, # la première ligne contient le nom des variables\n                          sep=',' # les variables sont separées par des virgules\n                          )\nstr(my_data_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'data.frame':\t150 obs. of  5 variables:\n $ sepal_length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ sepal_width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ petal_length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ petal_width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ species     : chr  \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...\n```\n:::\n:::\n\n\nIl existe (beaucoup) d'autres options dont les détails peuvent être trouvés dans l'aide.\n\n-   Fichier chargé à partir d'internet :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#url<- 'http://w3.mi.parisdescartes.fr/~vperduca/programmation/data/Iris.txt'\n#my_data_net <- read.table(url, \n                 #header=TRUE, # la première ligne contient le nom des variables\n                 #sep=';') # les variables sont separées par des ;\n#str(my_data_net)\n```\n:::\n\n\n-   Fichier Rdata :\n\nPour les données stockées dans le format `.Rda` ou `.Rdata`, l'importation se fait avec `load()` avec l'argument `file=` nom fichier. Si on veut charger des données directement à partir d'un url, ne pas oublier d'utiliser la fonction `url()` (cela n'était pas nécessaire dans `read.table()`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data_Rdata=load(file=\"Fichiers/starwars.Rdata\") \nstr(my_data_Rdata)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n chr \"starwars\"\n```\n:::\n:::\n\n\nL'exportation des données peut se faire dans un format de type texte (ou .csv, excel...) à l'aide de `write.file()` ou dans le format `.rda` ou `.Rdata` à l'aide de `save()`. Dans les deux cas, les deux principaux arguments sont `x=` données à sauvegarder et `file=` le nom du fichier (entre guillemets).\n\n# Document `R markdown`\n\nUn document `R markdown` (généralement enregistré avec l'extension `.rmd` ou `.Rmd`) permet d'une part d'utiliser la syntaxe [`markdown`](https://daringfireball.net/projects/markdown/) pour écrire du texte, mais aussi d'inclure des commandes `R` directement dans le document. Ainsi, un seul document contient le code et le commentaire, ce qui est un atout non négligeable pour des rapports ou présentations devant être mis à jour ou refaits régulièrement.\n\nIl est possible d'inclure les commandes `R` soit dans un bloc de code, appelé *chunk* dans **R Studio**, ou en ligne, appelé *inline chunk*.\n\nPour créer un document `R markdown` dans **R Studio**, vous pouvez cliquer sur l'icône avec un plus, puis sur *R markdown...*. Vous devez voir apparaître une interface vous demandant de choisir entre un document, une présentation, une application *Shiny* ou de choisir un *template* prédéfini. Nous allons rester sur le *document* pour le moment. De plus, vous pouvez indiquer le titre et l'auteur, ainsi que choisir le format de sortie ( **HTML** , **PDF** ou **Word** ). Nous allons garder HTML pour le moment.\n\n## En-tête\n\nLors de la création d'un nouveau document `R markdown`, vous devez voir apparaître en début de document une partie d'en-tête, comme ci-dessous, au format `YAML`.\n\n```         \n---\ntitle: \"Titre\"\nauthor: \"Romu\"\ndate: \"23/01/2023\"\noutput: html_document\n---\n```\n\nDans cet en-tête, nous pouvons donc définir le titre, éventuellement un sous-titre (avec `subtitle:`), le ou les auteurs, la date et des options de sortie. Pour le moment, nous allons garder la sortie au format HTML. Pour passer au format `PDF`, il faut écrire `pdf_document` dans `output` (ainsi qu'avoir $\\LaTeX$ installé sur sa machine - ce qui n'est pas le cas à l'IUT). Pour créer un document de type Word, il faut choisir `word_document` pour `output`.\n\nIl y a d'autres possibilités de sortie, ainsi que la possibilité d'ajouter d'autres paramètres de sortie, que nous ne verrons pas ici.\n\n### *Chunk*\n\nUn *chunk* sera donc un bloc de commande `R` (ou autre langage possible) qui sera exécuté par **R Studio**. Pour cela, il faut indiquer sur la première ligne le langage utilisé. Pour `R`, voici donc un exemple simple\n\n\n```{=html}\n<pre><code>&#96;&#96;&#96;{r}\n# code R\nsummary(mtcars)\n&#96;&#96;&#96;</code></pre>\n```\n\nDans le document sera donc intégré à la fois le code, ainsi que le résultat de son exécution. L'exemple donnera donc\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# code R\nsummary(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      mpg             cyl             disp             hp       \n Min.   :10.40   Min.   :4.000   Min.   : 71.1   Min.   : 52.0  \n 1st Qu.:15.43   1st Qu.:4.000   1st Qu.:120.8   1st Qu.: 96.5  \n Median :19.20   Median :6.000   Median :196.3   Median :123.0  \n Mean   :20.09   Mean   :6.188   Mean   :230.7   Mean   :146.7  \n 3rd Qu.:22.80   3rd Qu.:8.000   3rd Qu.:326.0   3rd Qu.:180.0  \n Max.   :33.90   Max.   :8.000   Max.   :472.0   Max.   :335.0  \n      drat             wt             qsec             vs        \n Min.   :2.760   Min.   :1.513   Min.   :14.50   Min.   :0.0000  \n 1st Qu.:3.080   1st Qu.:2.581   1st Qu.:16.89   1st Qu.:0.0000  \n Median :3.695   Median :3.325   Median :17.71   Median :0.0000  \n Mean   :3.597   Mean   :3.217   Mean   :17.85   Mean   :0.4375  \n 3rd Qu.:3.920   3rd Qu.:3.610   3rd Qu.:18.90   3rd Qu.:1.0000  \n Max.   :4.930   Max.   :5.424   Max.   :22.90   Max.   :1.0000  \n       am              gear            carb      \n Min.   :0.0000   Min.   :3.000   Min.   :1.000  \n 1st Qu.:0.0000   1st Qu.:3.000   1st Qu.:2.000  \n Median :0.0000   Median :4.000   Median :2.000  \n Mean   :0.4062   Mean   :3.688   Mean   :2.812  \n 3rd Qu.:1.0000   3rd Qu.:4.000   3rd Qu.:4.000  \n Max.   :1.0000   Max.   :5.000   Max.   :8.000  \n```\n:::\n:::\n\n\nIl est possible de nommer le *chunk* en lui donnant un label (sans espace, sans accent) après `r` dans les `{}`. Ceci est intéressant surtout dans l'étape de développement, car si une erreur arrive lors de l'exécution, il sera plus facile de retrouver dans quel *chunk* est l'erreur (indiqué lors de l'affichage de l'erreur).\n\nDe plus, il est possible de mettre des options dans le *chunk*, toujours dans les `{}`, après une `\",\"`. Voici quelques options classiques et utiles (avec leur valeur par défaut indiquée, si elle existe) :\n\n-   `include = TRUE` : si `FALSE`, le code est exécuté mais il n'est pas inclus dans le document (ni le code, ni son résultat)\n-   `echo = TRUE` : si `FALSE`, le code n'est pas affiché mais bien exécuté\n-   `eval = TRUE` : si `FALSE`, le code est affiché mais n'est pas exécuté\n-   `results = 'markup'` : permet de définir comment le résultat est affiché (intéressant pour les tableaux, cf plus loin)\n-   `fig.cap` : titre du graphique produit\n\nIl est possible de mettre plusieurs options, toutes séparées par des `\",\"`.\n\n### Quelques exemples\n\nDans la suite, voici quelques exemples de *chunks* avec options. Regardez le source pour mieux comprendre le fonctionnement.\n\nTout d'abord, on importe les données `iris.txt`, mais ce genre de code n'est souvent pas à inclure, dans le sens où l'on ne veut ni l'afficher, ni voir de résultat.\n\n\n\n\n\nEnsuite, la librairie `knitr` contient une fonction `kable()` permettant d'afficher un `data.frame` au format `markdown`. Cela permet d'avoir un résultat plus lisible qu'une sortie de console `R` classique.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::kable(head(Iris))\n```\n\n::: {.cell-output-display}\n| Sepal.Length| Sepal.Width| Petal.Length| Petal.Width|Species |\n|------------:|-----------:|------------:|-----------:|:-------|\n|          5.1|         3.5|          1.4|         0.2|setosa  |\n|          4.9|         3.0|          1.4|         0.2|setosa  |\n|          4.7|         3.2|          1.3|         0.2|setosa  |\n|          4.6|         3.1|          1.5|         0.2|setosa  |\n|          5.0|         3.6|          1.4|         0.2|setosa  |\n|          5.4|         3.9|          1.7|         0.4|setosa  |\n:::\n:::\n\n\nEnfin, on peut vouloir faire un graphique, ce qui pourrait donner ce qui suit. Pour ce genre de présentation, nous pouvons décider de ne pas afficher le code permettant de les obtenir.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Répartition de la longeur du sépale en fonction du type d'iris](Introduction-à-R_files/figure-html/graph-1.png){width=672}\n:::\n:::\n\n\n## *Inline chunk*\n\nOn peut faire des *chunks* en ligne en encadrant le code avec des `` ` `` et en commencant le code par un `r`. Par exemple, on peut dire que dans le jeu de données `Iris` sont présentés 150 individus et 5 variables.\n\n## Paramètres globaux des *chunks*\n\nIl est possible de déterminer des paramètres globaux pour tous les blocs *chunks* du document (sauf paramètres locaux précisés). Ceci doit se faire comme suit, avec la fonction `set()` de l'objet `opts_chunk` de la librairie `knitr`. Il est par exemple possible de définir `echo=FALSE` pour n'avoir aucun code apparaissant dans le document.\n\n```         \nknitr::opts_chunk$set(...)\n```\n\nDans votre document, penser à nommer chaque chunk différement. Et n'hésiter pas à commenter le document pour le rendre plus conforme à ce qu'on pourrait vouloir produire comme document.\n\nVous trouverez sur le site [rmarkdown](https://daringfireball.net/projects/markdown/) beaucoup d'informations et de compléments sur cette librairie. Beaucoup sont résumées dans ce [document](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf).\n\n\n# Concepts avancés\n\nLes boucles doivent être utilisées avec parcimonie en **R** car elles sont généralement inefficaces et lentes à éxécuter. Dans la majeure partie des cas, il est possible de vectoriser les calculs pour éviter les boucles explicites. Il est également possible de créer ses propres fonctions. La meilleur façon de procéder étant d'utiliser les fonctions `apply, sapply, tapply, mapply, lapply` pour programmer de manière plus efficace.\n\n## Schémas de programmation\n\n### Choix (impliquant des conditions)\n\n-   `if (condition) branche.vraie else branche.fausse` : si `condition` est vraie, `branche.vraie` est exécutée, sinon ce sera `branche.fausse`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- -2\nif (x<0){\n  cat(\"x est négatif\")\n} else {\n  cat(\"x est positif\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx est négatif\n```\n:::\n:::\n\n\n-   `while (condition) expression` : exécute `expression` tant que `condition` est vraie\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10\nwhile (x>0){\n  x <- x-1\n}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n### Itération ou boucle\n\n-   `for (variable in suite) expression` : exécute `expression` successivement pour chaque valeur de `variable` contenue dans `suite`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0\nfor (i in (1:10)){\n  x <- x+1\n}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\n## Fonctions définies par l'usager\n\nOn définit une nouvelle fonction avec la syntaxe suivante : `fun <- function(arguments) expression` où\n\n-   `fun` est le nom de la fonction\n\n-   `arguments` est la liste des arguments, séparés par des virgules\n\n-   `expression` constitue le corps de la fonction, soit une expression ou un groupe d'expressions réunies par des accolades.\n\nLa plupart des fonctions sont écrites dans le but de retourner un résultat. Ici, une fonction retourne tout simplement le résultat de la dernière expression du corps de la fonction. On peut utiliser la fonction `return()` pour retourner un résultat qui n'est pas à la dernière ligne de la fonction.\n\n**Exemple:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nma.fonction <- function(x,y=10){ # la valeur par défaut de y est 10\n  z=x-y\n  return(z)\n}\nma.fonction(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -8\n```\n:::\n\n```{.r .cell-code}\nma.fonction(2,4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -2\n```\n:::\n\n```{.r .cell-code}\nma.fonction(y=1, x=4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n\nToute variable définie dans une fonction est *locale* et n'apparaît pas dans l'espace de travail: essayer d'exécuter\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nMoyenne <- function(x){\n  if (mode(x)==\"numeric\"){\n    M <- mean(x)\n    return(M)\n  } else {\n    cat(\"x n'est pas numérique\")\n  }\n}\nMoyenne(c(1,3,5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nMoyenne(c(\"a\",\"b\",\"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx n'est pas numérique\n```\n:::\n:::\n\n\n## Fonction `apply()`\n\nLa fonction `apply()` sert à appliquer une fonction quelconque sur une partie d'une matrice, ou plus généralement, d'un tableau. La syntaxe de la fonction est la suivante `apply(X, MARGIN, FUN, ...)` où\n\n-   `X` est une matrice ou un tableau\n\n-   `MARGIN` est un vecteur d'entiers contenant la (ou les) dimensions de la matrice ou tableau sur lesquelles la fonction doit s'appliquer\n\n-   `FUN` est la fonction à appliquer.\n\nLorsque `X` est une matrice, `apply` sert principalement à calculer des sommaires par ligne (dimension 1) ou par colonne (dimension 2).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(sample(1:100, 20, rep = TRUE), 5, 4)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]   18   59   41   46\n[2,]   16   37   65   40\n[3,]   14   87  100   54\n[4,]   91   40   87   62\n[5,]   28   17   11   18\n```\n:::\n\n```{.r .cell-code}\napply(x,1,var)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  292.66667  403.00000 1474.91667  564.66667   49.66667\n```\n:::\n\n```{.r .cell-code}\napply(x,2,min)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14 17 11 18\n```\n:::\n:::\n\n\n## Fonctions `lapply()` et `sapply()`\n\nLes fonctions `lapply(`) et `sapply()` sont similaires à la fonction `apply()` puisqu'elles permettent d'appliquer une fonction aux éléments d'une structure (vecteur ou liste). Leur syntaxe est similaire `lapply(X,FUN,...), sapply(X,FUNC,...)`.\n\nLa fonction `lapply()` applique une fonction `FUN` à tous les éléments d'un vecteur ou d'une liste `X` et retourne le résultat sous la forme d'une liste. La fonction `sapply()` est similaire, sauf que le résultat est retourné sous forme de vecteur, si possible. Le résultat est donc simplifié par rapport à celui de `lapply()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- lapply(5:8, sample, x = 1:10)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1]  2  7 10  9  5\n\n[[2]]\n[1] 5 6 3 1 4 2\n\n[[3]]\n[1] 7 2 6 9 3 1 4\n\n[[4]]\n[1] 10  4  1  7  5  9  6  8\n```\n:::\n\n```{.r .cell-code}\nlapply(x,mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 6.6\n\n[[2]]\n[1] 3.5\n\n[[3]]\n[1] 4.571429\n\n[[4]]\n[1] 6.25\n```\n:::\n\n```{.r .cell-code}\nsapply(x,mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6.600000 3.500000 4.571429 6.250000\n```\n:::\n:::\n\n\nSi le résultat de chaque application de la fonction est un vecteur et que les vecteurs sont tous de la même longueur, alors `sapply` retourne une matrice, remplie comme toujours par colonne :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- lapply(rep(5, 3), sample, x = 1:10)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 8 4 5 6 2\n\n[[2]]\n[1]  2  5  3  4 10\n\n[[3]]\n[1] 5 6 4 1 9\n```\n:::\n\n```{.r .cell-code}\nsapply(x,sort)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    2    2    1\n[2,]    4    3    4\n[3,]    5    4    5\n[4,]    6    5    6\n[5,]    8   10    9\n```\n:::\n:::\n\n\n## Fonction particulière\n\nOn a souvent besoin d'utiliser une fonction spécifique dans les fonctions comme `lapply()` ou `sapply()`. On peut par exemple la définir au préalable et l'utiliser comme une autre.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl = list(a = \"chaîne\", \n  b = 12, \n  c = 1:10, \n  d = head(mtcars), \n  e = list(x = 1:10, y = log(1:10)))\n\ninfoElement <- function(e) {\n    return(c(classe = class(e), longueur = length(e)))\n}\n\nsapply(l, infoElement)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         a           b         c         d            e     \nclasse   \"character\" \"numeric\" \"integer\" \"data.frame\" \"list\"\nlongueur \"1\"         \"1\"       \"10\"      \"11\"         \"2\"   \n```\n:::\n:::\n\n\nIl est également possible de déclarer directement la fonction dans les fonctions `lapply()` et `sapply()`. On parle alors de **fonction anonyme**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(l, function(e) {\n  return(c(classe = class(e), longueur = length(e)))\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         a           b         c         d            e     \nclasse   \"character\" \"numeric\" \"integer\" \"data.frame\" \"list\"\nlongueur \"1\"         \"1\"       \"10\"      \"11\"         \"2\"   \n```\n:::\n:::\n",
    "supporting": [
      "Introduction-à-R_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}